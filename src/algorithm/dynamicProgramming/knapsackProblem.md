# 背包问题（0 1背包问题）

## 基础知识

01背包问题，一般都有i个物品，每个只能选取0或者1个，背包容量为j，求放入背包最大价值是多少。

比如 ：	

||重量|	价值|
|----|---|---|
|物品0|	1|	15|
|物品1|	3|	20|
|物品2|	4|	30|
背包容量为j，比如5，求最大的价值是多少。

除此之外，常见的有很多01背包变种问题，见下一章

## 解决什么问题

1. **分割等和子集**：能否选出部分元素，使其和等于总和的一半？，比如 Leetcode 416题
2. **目标和**：给数字添加正负号，使和为 target
3. **一和零**：在0和1的数量限制下，找到最大子集。
4. **硬币组合**（硬币只能用一次）：用给定硬币凑出某金额的最少硬币数或组合数。

## 算法模版

1. 定义 dp[i] 或 dp[i][j]
2. 定义初始值，比如 i = 0 这一行数据，j = 0 这一列的数据
3. 动态规划转移方程
4. 根据转移方程确定遍历顺序，从0到i还是从i到0
5. 返回结果，一般是 dp[i] 或 dp[i][j]

动态规划转移方程：

### 二维数组模版，好理解：
* 经典01背包问题
```java
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
```
* 可行性问题
```java
dp[i][j] = dp[i - 1][j] | dp[i - 1][j - value[i]];
```
### 一维数组 进阶
* 经典01背包方程：
```java
dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
```
其中 j 为背包容量，优化后为一维数组。

* 可行性问题方程：
```java
dp[j] = dp[j] || dp[j - nums[i]]
```
用于判断是否能装满容量 j。


